function [b0,b1,b2] = computeblocks(geometryData, t001, t101, t011, ...
    t003, t103, t013, t203, t023, t113, t303, t033, t213, t123, regularization)
%% COMPUTEBLOCKS evaluates the three 3M x 3 block matrices B0,B1,B2 from the regularized Stokeslet surface matrix
% Parameters:
%   geometryData: struct with geometric data for triangle and field points
%   t001,t101,t011: M x 1 vectors corresponding to T_{0,0,1}, T_{1,0,1},
%   T_{0,1,1}
%   t003: M x 1 vectors corresponding to T_{0,0,3}, T_{1,0,3}, T_{0,1,3},
%   T_{2,0,3}, T_{0,2,3}, T_{1,1,3}, T_{3,0,3}, T_{0,3,3}, T_{2,1,3}, and
%   T_{1,2,3}
%   regularization: the blob parameter
%   Output:
%   b0, b1, b2; 3M x 3 matrices corresponding to the contributions from
%   forces at vertices y_0, y_1, y_2

%unpackage geometryData (M x 1 vectors)
x0 = geometryData.x0;
r1 = x0(1,:)';
r2= x0(2,:)';
r3 = x0(3,:)';
% 3 x 1 vectors
vhat = geometryData.vhat;
v1=vhat(1); v2=vhat(2); v3=vhat(3);
what = geometryData.what;
w1=what(1); w2=what(2); w3=what(3);
what = geometryData.what;
%the rest are scalars
ell1 = geometryData.ell1;
ell2 = geometryData.ell2;

%the 3x3 block matrices that appear often
identity = eye(3,3);
vvt = vhat * vhat';
wwt = what * what';
vwt = vhat * what';
wvt = vwt';

b0 = kron(t001 + regularization.^2 .* t003 - t101  ...
    - regularization.^2. *t103, identity) ...
    + kron(ell1.^2 .* t203 - ell1.^2 .* t303, vvt) ...
    + kron(ell2.^2 .* t023 - ell2.^2 .* t123, wwt)  ...
    + kron(ell1.*ell2 .* t113 - ell1.*ell2 .* t213, vwt + wvt) ...
    + kronx0vorw(ell1.*t103  - ell1.*t203, r1, r2, r3, v1,v2,v3) ...
    + kronx0vorw(ell2.*t013  - ell2.*t113, r1, r2, r3, w1,w2,w3) ...
    + kronx0x0(t003 - t103, r1, r2, r3);

b1 = kron(t101 + regularization.^2 .* t103 - t011  ...
    - regularization.^2. *t013, identity) ...
    + kron(ell1.^2 .* t303 - ell1.^2 .* t213, vvt) ...
    + kron(ell2.^2 .* t123 - ell2.^2 .* t033, wwt)  ...
    + kron(ell1.*ell2 .* t213 - ell1.*ell2 .* t123, vwt + wvt) ...
    + kronx0vorw(ell1.*t203  - ell1.*t113, r1, r2, r3, v1,v2,v3) ...
    + kronx0vorw(ell2.*t113  - ell2.*t023, r1, r2, r3, w1,w2,w3) ...
    + kronx0x0(t103 - t013, r1, r2, r3);

b2 = kron(t011 + regularization.^2 .* t013, identity)  ...
    + kron(ell1.^2 .* t213, vvt) ...
    + kron(ell2.^2 .* t033, wwt)  ...
    + kron(ell1.*ell2 .* t123, vwt + wvt) ...
    + kronx0vorw(ell1.*t113, r1, r2, r3, v1,v2,v3) ...
    + kronx0vorw(ell2.*t023, r1, r2, r3, w1,w2,w3) ...
    + kronx0x0(t013, r1, r2, r3);



    function out = kronx0x0(t,r1,r2,r3)
        out = kron(t .* r1.*r1, diag([1,0,0])) ...
            + kron(t .* r2.*r2, diag([0,1,0])) ...
            + kron(t .* r3.*r3, diag([0,0,1])) ...
            + kron(t .* r1.*r2, [0,1,0; 1,0,0; 0,0,0]) ...
            + kron(t .* r1.*r3, [0,0,1; 0,0,0; 1,0,0]) ...
            + kron(t .* r2.*r3, [0,0,0; 0,0,1; 0,1,0]);
    end

    function out = kronx0vorw(t,r1,r2,r3,v1,v2,v3)
        out = kron(t .* 2.*v1.*r1, diag([1,0,0])) ...
            + kron(t .* 2.*v2.*r2, diag([0,1,0])) ...
            + kron(t .* 2.*v3.*r3, diag([0,0,1])) ...
            + kron(t .* (v1.*r2 + v2.*r1), [0,1,0; 1,0,0; 0,0,0]) ...
            + kron(t .* (v1.*r3 + v3.*r1), [0,0,1; 0,0,0; 1,0,0]) ...
            + kron(t .* (v2.*r3 + v3.*r2), [0,0,0; 0,0,1; 0,1,0]);
    end
end